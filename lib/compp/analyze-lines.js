// Generated by CoffeeScript 1.9.2
var C99CommentBackslashRegex, C99CommentNoBackslashRegex, ConcatBackslashNewlinesStream, addDefine, addFunctionMacro, addObjectMacro, analyzeLines, applyDefines, applyFunctionDefine, argumentRegex, backslashNewlineRegex, charInQuotesRegex, condRegex, defineErrorCol, dir, directiveRegex, disallowedConditionalChars, doIfCondMath, fileTokenRegex, fs, gccADir, gccArchDirs, gccVersionDirs, getBackslashNewlinesBeforeToken, hashRegex, ifDefinedCallback, insertInclude, leadingWhitespaceRegex, lineTokenRegex, localHeaderRegex, localIncludeDirs, multipleWhitespaceRegex, notWhitespaceRegex, numberRegex, parenCommaWhitespaceRegex, parentheticalExprRegex, path, processComments, processError, processIf, processIfConstExpr, processLine, processLineDirective, processPragma, processSourceLine, removeDefine, slashStarBeginRegex, slashStarEndRegex, stream, stringInQuotes, stripQuotesRegex, stripSideCaratsRegex, sysIncludeDirs, systemHeaderRegex, throwError, tokenRegex, trailingWhitespaceRegex, whitespaceRegex,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

stream = require('stream');

ConcatBackslashNewlinesStream = require('./concat-backslash-newline-stream');

directiveRegex = /^\s*#\s*[a-z_]+/g;

tokenRegex = /\b[a-zA-Z_][a-zA-Z0-9_]{0,31}\b/g;

numberRegex = /[0-9]+/g;

backslashNewlineRegex = /\\\n/g;

stringInQuotes = /".*"/g;

condRegex = /(if|else)/g;

notWhitespaceRegex = /[^\s]/g;

leadingWhitespaceRegex = /^\s+/g;

trailingWhitespaceRegex = /\s+$/g;

whitespaceRegex = /\s/g;

multipleWhitespaceRegex = /\s+/g;

hashRegex = /#/g;

C99CommentBackslashRegex = /\/\/.*\\\n/g;

C99CommentNoBackslashRegex = /\/\/.*/g;

slashStarBeginRegex = /\/\*/g;

slashStarEndRegex = /\*\//g;

parentheticalExprRegex = /\([^\)]*\)/g;

parenCommaWhitespaceRegex = /[\(\),\s]/g;

argumentRegex = /[^,]+[,\)]/g;

charInQuotesRegex = /'(.)'/g;

fileTokenRegex = /\b__FILE__\b/g;

lineTokenRegex = /\b__LINE__\b/g;

systemHeaderRegex = /^\s*<.+>/g;

localHeaderRegex = /^\s*".+"/g;

stripSideCaratsRegex = /[<>]/g;

stripQuotesRegex = /"/g;

disallowedConditionalChars = /[^0-9\(\)!%\^&\*\-\+\|\/=~<>\\\s]/g;

defineErrorCol = 2;

sysIncludeDirs = ["/usr/local/include", "/usr/include", "/usr/include/linux", "/usr/include/sys"];

localIncludeDirs = [];

gccArchDirs = fs.readdirSync("/usr/lib/gcc").map(function(inode) {
  return path.join("/usr/lib/gcc", inode);
}).filter(function(inode) {
  var err;
  try {
    return (fs.statSync(inode)).isDirectory();
  } catch (_error) {
    err = _error;
    return false;
  }
});

gccVersionDirs = ((function() {
  var j, len, results;
  results = [];
  for (j = 0, len = gccArchDirs.length; j < len; j++) {
    gccADir = gccArchDirs[j];
    results.push(fs.readdirSync(gccADir));
  }
  return results;
})()).map(function(verDirArr) {
  var j, len, results, verDir;
  results = [];
  for (j = 0, len = verDirArr.length; j < len; j++) {
    verDir = verDirArr[j];
    results.push(path.join(gccADir, verDir));
  }
  return results;
}).reduce(function(arr1, arr2) {
  return arr1.concat(arr2);
});

sysIncludeDirs = ((function() {
  var j, len, results;
  results = [];
  for (j = 0, len = gccVersionDirs.length; j < len; j++) {
    dir = gccVersionDirs[j];
    results.push(path.join(dir, "include"));
  }
  return results;
})()).concat(sysIncludeDirs);

throwError = function(file, line, line_num, col, err) {
  var i, j, ref;
  console.error(file + ":" + line_num + ":" + col + ": error: " + err);
  process.stderr.write(line);
  for (i = j = 1, ref = col - 1; j <= ref; i = j += 1) {
    process.stderr.write(" ");
  }
  process.stderr.write("^~~\n");
  return process.exit(-1);
};

getBackslashNewlinesBeforeToken = function(str, tok) {
  var i, ind, j, num, prevChar, ref;
  ind = str.indexOf(tok);
  if (ind === null || ind === -1) {
    return 0;
  }
  prevChar = "";
  num = 0;
  for (i = j = 0, ref = ind - 1; j <= ref; i = j += 1) {
    if (str.charAt(i) === "\n" && prevChar === "\\") {
      ++num;
    }
    prevChar = str.charAt(i);
  }
  return num;
};

applyFunctionDefine = function(fnDefn, args, token, str, defines, macrosExpanded, opts, line) {
  var curStr, i, j, ref, tokenIndex;
  tokenIndex = str.indexOf(token);
  if (args.length !== fnDefn.args.length) {
    throwError(opts.file, str, opts.line, tokenIndex, "Incorrect number of arguments passed to function-like macro: should " + ("be " + fnDefn.args.length + ", not " + args.length));
  }
  curStr = fnDefn.text;
  for (i = j = 0, ref = args.length - 1; j <= ref; i = j += 1) {
    curStr = curStr.replace(new RegExp("\\b" + fnDefn.args[i] + "\\b"), applyDefines(args[i], defines, opts, macrosExpanded));
  }
  return applyDefines(str.substr(0, tokenIndex) + curStr + str.substr(tokenIndex + token.length), defines, opts, macrosExpanded);
};

applyDefines = function(str, defines, opts, macrosExpanded, line) {
  var argInP, argsArr, argsInParens, defineFunctionRegexStr, defineObjectRegexStr, defineStr, defineVal, definesToSend, i, j, k, len, ref, replaceString, res, tkwArgs, tokensWithArgs;
  str = str.replace(backslashNewlineRegex, "");
  for (defineStr in defines) {
    defineVal = defines[defineStr];
    defineObjectRegexStr = "\\b" + defineStr + "\\b";
    defineFunctionRegexStr = "\\b" + defineStr + "\\([^\\)]*\\)";
    if ((!macrosExpanded) || (macrosExpanded.indexOf(defineStr) === -1)) {
      definesToSend = [];
      if (macrosExpanded) {
        definesToSend = macrosExpanded;
      }
      if (defineVal.type === "object" && str.match(new RegExp(defineObjectRegexStr, "g"))) {
        definesToSend.push(defineStr);
        replaceString = applyDefines(defineVal.text, defines, opts, definesToSend, line);
        str = str.replace(new RegExp(defineObjectRegexStr, "g"), replaceString);
      } else if (defineVal.type === "function" && str.match(new RegExp(defineFunctionRegexStr, "g"))) {
        definesToSend.push(defineStr);
        tokensWithArgs = str.match(new RegExp(defineFunctionRegexStr, "g"));
        argsInParens = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tokensWithArgs.length; j < len; j++) {
            tkwArgs = tokensWithArgs[j];
            results.push(tkwArgs.match(parentheticalExprRegex)[0]);
          }
          return results;
        })();
        argsArr = [];
        res = null;
        for (j = 0, len = argsInParens.length; j < len; j++) {
          argInP = argsInParens[j];
          res = (argInP.match(argumentRegex)).map(function(s) {
            return s.replace(parenCommaWhitespaceRegex, "");
          });
          if (res.length === 1 && res[0] === "") {
            res = [];
          }
          argsArr.push(res);
        }
        if (tokensWithArgs.length !== argsArr.length) {
          throw new Error("lengths should be the same here!\n" + ("(this is a bug; " + tokensWithArgs.length + " and " + argsArr.length + ")"));
        }
        for (i = k = 0, ref = tokensWithArgs.length - 1; k <= ref; i = k += 1) {
          str = applyFunctionDefine(defineVal, argsArr[i], tokensWithArgs[i], str, defines, definesToSend, opts, line);
        }
      }
    }
  }
  return str.replace(fileTokenRegex, opts.file).replace(lineTokenRegex, opts.line);
};

insertInclude = function(directive, restOfLine, outStream, opts, dirname, line) {
  var err, filePath, found, includeDir, j, len, localHeader, newPipe, prevFile, prevLine, ref, ref1, res, sysHeader;
  sysHeader = (ref = restOfLine.match(systemHeaderRegex)) != null ? ref[0] : void 0;
  localHeader = (ref1 = restOfLine.match(localHeaderRegex)) != null ? ref1[0] : void 0;
  found = false;
  if (sysHeader) {
    sysHeader = sysHeader.replace(leadingWhitespaceRegex, "");
    sysHeader = sysHeader.replace(stripSideCaratsRegex, "");
    for (j = 0, len = sysIncludeDirs.length; j < len; j++) {
      includeDir = sysIncludeDirs[j];
      try {
        filePath = path.join(includeDir, sysHeader);
        res = fs.statSync(filePath);
        console.error("FOUND: " + filePath);
        prevFile = opts.file;
        prevLine = opts.line;
        prevLineStream.pause();
        newPipe = analyzeLines(filePath, fs.createReadStream(filePath), opts);
        newPipe.pipe(outStream);
        newPipe.on('end', function() {
          var matches;
          prevLineStream.unpause();
          console.error("RETURN:");
          console.error("FILE: " + opts.file + ": NEW: " + prevFile);
          console.error("LINE: " + opts.line + ": NEW: " + prevLine);
          opts.file = prevFile;
          opts.line = prevLine;
          matches = restOfLine.match(backslashNewlineRegex);
          if (matches) {
            opts.line += matches.length;
          }
          return ++opts.line;
        });
        found = true;
      } catch (_error) {
        err = _error;
        res = null;
      }
      if (found) {
        break;
      }
    }
    if (!found) {
      return throwError(opts.file, line, opts.line, defineErrorCol, "Include file <" + sysHeader + "> not found.");
    }
  }
};

addFunctionMacro = function(defineToken, lineAfterToken, opts, line) {
  var args, argsArr, ref;
  args = (ref = lineAfterToken.match(parentheticalExprRegex)) != null ? ref[0] : void 0;
  if (!args) {
    throwError(opts.file, lin, opts.line, defineErrorCol, "Function-like macro construction has no closing paren.");
  }
  argsArr = (args.match(argumentRegex || [])).map(function(s) {
    return s.replace(parenCommaWhitespaceRegex, "");
  });
  if (argsArr.length === 1 && argsArr[0] === "") {
    argsArr = [];
  }
  return opts.defines[defineToken] = {
    text: lineAfterToken.substr(lineAfterToken.indexOf(args) + args.length).replace(leadingWhitespaceRegex, "").replace(trailingWhitespaceRegex, ""),
    type: "function",
    args: argsArr
  };
};

addObjectMacro = function(defineToken, lineAfterToken, opts, line) {
  var replaceToken;
  replaceToken = lineAfterToken.replace(backslashNewlineRegex, "").replace(leadingWhitespaceRegex, "").replace(trailingWhitespaceRegex, "");
  return opts.defines[defineToken] = {
    text: replaceToken,
    type: "object"
  };
};

addDefine = function(directive, restOfLine, outStream, opts, line) {
  var defineToken, lineAfterToken, matches, ref;
  defineToken = (ref = restOfLine.match(tokenRegex)) != null ? ref[0] : void 0;
  if (!defineToken) {
    throwError(opts.file, line, opts.line, defineErrorCol, "No token given to #define.");
  }
  lineAfterToken = restOfLine.substr(restOfLine.indexOf(defineToken) + defineToken.length);
  if (lineAfterToken.charAt(0) === "(") {
    addFunctionMacro(defineToken, lineAfterToken, opts, line);
  } else {
    addObjectMacro(defineToken, lineAfterToken, opts, line);
  }
  matches = restOfLine.match(backslashNewlineRegex);
  if (matches) {
    opts.line += matches.length;
  }
  return ++opts.line;
};

removeDefine = function(directive, restOfLine, outStream, opts, line) {
  var matches, ref, undefToken;
  undefToken = (ref = restOfLine.match(tokenRegex)) != null ? ref[0] : void 0;
  if (!undefToken) {
    throwError(opts.file, line, opts.line, defineErrorCol, "No token given to #undef.");
  }
  delete opts.defines[undefToken];
  matches = restOfLine.match(backslashNewlineRegex);
  if (matches) {
    opts.line += matches.length;
  }
  return ++opts.line;
};

processError = function(directive, restOfLine, opts, line) {
  return throwError(opts.file, line, opts.line, defineErrorCol, restOfLine.replace(leadingWhitespaceRegex, "").replace(trailingWhitespaceRegex, ""));
};

processPragma = function(directive, restOfLine, outStream, opts, line) {
  var matches;
  outStream.write(line);
  matches = restOfLine.match(backslashNewlineRegex);
  if (matches) {
    opts.line += matches.length;
  }
  return ++opts.line;
};

processLineDirective = function(directive, restOfLine, outStream, opts, line) {
  var backslashesBeforeToFile, backslashesBeforeToLine, ref, ref1, toFile, toLine;
  toLine = (ref = restOfLine.match(tokenRegex)) != null ? ref[0] : void 0;
  backslashesBeforeToLine = getBackslashNewlinesBeforeToken(restOfLine, toLine);
  if (!toLine) {
    throwError(opts.file, line, opts.line, directive.length, "No line number given in " + directive + " directive.");
  }
  if (!toLine.match(numberRegex)) {
    throwError(opts.file, opts.line + backslashesBeforeToLine, directive.length, "Invalid line number given in " + directive + " directive.");
  }
  toFile = (ref1 = restOfLine.match(tokenRegex)) != null ? ref1[1] : void 0;
  backslashesBeforeToFile = getBackslashNewlinesBeforeToken(restOfLines, toFile);
  if (toFile) {
    if (!toFile.match(stringInQuotes)) {
      throwError(opts.file, line, opts.line + backslashesBeforeToFile, directive.length, "Invalid file name given in " + directive + " directive.");
    } else {
      opts.file = toFile;
    }
  }
  return opts.line = toLine;
};

ifDefinedCallback = function(opts, line) {
  return function(str, g1) {
    var tokMatches, tokenMatch;
    tokMatches = g1.match(tokenRegex);
    if (!tokMatches || tokMatches.length > 1) {
      return throwError(opts.file, line, opts.line, line.indexOf("defined"), "Invalid token provided to 'defined' operator in preprocessor " + "conditional.");
    } else {
      tokenMatch = tokMatches[0];
      if (opts.defines[g1]) {
        return ' 1 ';
      } else {
        return ' 0 ';
      }
    }
  };
};

doIfCondMath = function(str, opts, line) {
  var err, outExpansion, outStr, ref, res, resVal;
  str = applyDefines(str, opts.defines, opts, [], line);
  str = str.replace(backslashNewlineRegex, "");
  str = str.replace(charInQuotesRegex, function(str, g1) {
    return g1.charCodeAt(0);
  });
  res = str.match(disallowedConditionalChars || str.match(tokenRegex));
  if (res) {
    outStr = ((ref = str.match(disallowedConditionalChars)) != null ? ref[0] : void 0) || str.match(tokenRegex)[0];
    outExpansion = str.replace(multipleWhitespaceRegex, " ").replace(trailingWhitespaceRegex, "").replace(leadingWhitespaceRegex, "");
    return throwError(opts.file, line, opts.line, defineErrorCol, ("invalid token in preprocessor conditional: '" + outStr + "' in expansion:\n") + ("'" + outExpansion + "':"));
  } else {
    try {
      resVal = eval(str);
    } catch (_error) {
      err = _error;
      console.error(str);
      throwError(opts.file, line, opts.line, defineErrorCol, "invalid expression in preprocessor conditional: " + err);
    }
    return resVal > 0;
  }
};

processIfConstExpr = function(directive, restOfLine, outStream, opts, dirname, line) {
  var boolResult;
  if (directive === "elif") {
    if (opts.ifStack.length === 0) {
      throwError(opts.file, line, opts.line, defineErrorCol, "#elif without opening #if");
    } else if (opts.ifStack[opts.ifStack.length - 1].hasBeenTrue) {
      opts.ifStack[opts.ifStack.length - 1].isCurrentlyTrue = false;
      return;
    }
  }
  if (directive === "if" || "elif") {
    restOfLine = restOfLine.replace(/\bdefined\s*\(([^\)]*)\)/g, ifDefinedCallback(opts, line));
    restOfLine = restOfLine.replace(/\bdefined\s*(\w+)/g, ifDefinedCallback(opts, line));
    boolResult = doIfCondMath(restOfLine, opts, line);
    if (directive === "if") {
      return opts.ifStack.push({
        hasBeenTrue: boolResult,
        isCurrentlyTrue: boolResult,
        ifLine: opts.line,
        ifFile: opts.file,
        ifText: line
      });
    } else {
      return opts.ifStack[opts.ifStack.length - 1] = {
        hasBeenTrue: boolResult,
        isCurrentlyTrue: boolResult,
        ifLine: opts.line,
        ifFile: opts.file,
        ifText: line
      };
    }
  } else {
    return throwError(opts.file, line, opts.line, defineErrorCol, "unrecognized preprocessor directive: " + directive);
  }
};

processIf = function(directive, restOfLine, outStream, opts, dirname, line) {
  var matches, nextToken, ref, retCondStackObj;
  nextToken = (ref = restOfLine.match(tokenRegex)) != null ? ref[0] : void 0;
  retCondStackObj = {
    ifLine: opts.line,
    ifFile: opts.file,
    ifText: line
  };
  if (directive === "ifdef") {
    if (!nextToken) {
      throwError(opts.file, line, opts.line, defineErrorCol, "No token given to #ifdef");
    } else if (opts.defines[nextToken]) {
      retCondStackObj.isCurrentlyTrue = true;
      retCondStackObj.hasBeenTrue = true;
    } else {
      retCondStackObj.isCurrentlyTrue = false;
      retCondStackObj.hasBeenTrue = false;
    }
    opts.ifStack.push(retCondStackObj);
  } else if (directive === "ifndef") {
    if (!nextToken) {
      throwError(opts.file, line, opts.line, defineErrorCol, "No token given to #ifndef");
    } else if (!opts.defines[nextToken]) {
      retCondStackObj.isCurrentlyTrue = true;
      retCondStackObj.hasBeenTrue = true;
    } else {
      retCondStackObj.isCurrentlyTrue = false;
      retCondStackObj.hasBeenTrue = false;
    }
    opts.ifStack.push(retCondStackObj);
  } else if (directive === "else") {
    if (opts.ifStack.length === 0) {
      throwError(opts.file, line, opts.line, defineErrorCol, "#else without opening #if");
    } else if (opts.ifStack[opts.ifStack.length - 1].hasBeenTrue) {
      opts.ifStack[opts.ifStack.length - 1].isCurrentlyTrue = false;
    } else {
      opts.ifStack[opts.ifStack.length - 1].isCurrentlyTrue = true;
      opts.ifStack[opts.ifStack.length - 1].hasBeenTrue = true;
    }
  } else if (directive === "endif") {
    if (opts.ifStack.length === 0) {
      throwError(opts.file, line, opts.line, defineErrorCol, "#endif without opening #if");
    } else {
      opts.ifStack.pop();
    }
  } else {
    processIfConstExpr(directive, restOfLine, outStream, opts, dirname, line);
  }
  matches = line.match(backslashNewlineRegex);
  if (matches) {
    opts.line += matches.length;
  }
  return ++opts.line;
};

processSourceLine = function(line, outStream, opts, origLine) {
  var matches, outLine;
  outLine = applyDefines(line, opts.defines, opts, origLine);
  outStream.write(outLine);
  matches = line.match(backslashNewlineRegex);
  if (matches) {
    opts.line += matches.length;
  }
  return ++opts.line;
};

processComments = function(line, opts) {
  var c, j, len, newLine, prevChar;
  newLine = [];
  prevChar = "";
  for (j = 0, len = line.length; j < len; j++) {
    c = line[j];
    if (!opts.isInComment) {
      newLine.push(c);
    }
    if (!opts.isInComment) {
      if (c === "*" && prevChar === "/") {
        opts.isInComment = true;
        newLine.pop();
        newLine.pop();
      }
    } else {
      if (indexOf.call("/", c) >= 0 && prevChar === "*") {
        opts.isInComment = false;
      }
      if (c === "\n" && prevChar === "\\") {
        newLine.push("\\");
        newLine.push("\n");
      }
    }
    prevChar = c;
  }
  newLine = newLine.join("");
  newLine = newLine.replace(C99CommentBackslashRegex, "\\\n");
  newLine = newLine.replace(C99CommentNoBackslashRegex, "");
  return newLine;
};

processLine = function(line, outStream, opts, inComment, dirname) {
  var directive, matches, origLine, ref, restOfLine;
  origLine = line;
  line = processComments(line, opts);
  directive = (ref = line.match(directiveRegex)) != null ? ref[0] : void 0;
  restOfLine = "";
  if (!directive) {
    restOfLine = line;
  } else {
    restOfLine = line.substr((line.indexOf(directive)) + directive.length);
    directive = directive.replace(whitespaceRegex, "");
    directive = directive.replace(hashRegex, "");
  }
  if (opts.ifStack.length === 0 || opts.ifStack[opts.ifStack.length - 1].isCurrentlyTrue) {
    switch (directive) {
      case "include":
        return insertInclude(directive, restOfLine, outStream, opts, dirname, origLine);
      case "define":
        return addDefine(directive, restOfLine, outStream, opts, origLine);
      case "undef":
        return removeDefine(directive, restOfLine, outStream, opts, origLine);
      case "error":
        return processError(directive, restOfLine, opts, origLine);
      case "pragma":
        return processPragma(directive, restOfLine, outStream, opts, origLine);
      case "line":
        return processLineDirective(directive, restOfLine, outStream, opts, origLine);
      default:
        if (directive) {
          return processIf(directive, restOfLine, outStream, opts, dirname, origLine);
        } else {
          return processSourceLine(line, outStream, opts, origLine);
        }
    }
  } else {
    if (directive && directive.match(condRegex)) {
      return processIf(directive, restOfLine, outStream, opts, dirname, origLine);
    } else {
      if (directive && restOfLine) {
        matches = (directive + restOfLine).match(backslashNewlineRegex);
        if (matches !== null) {
          opts.line += matches.length;
        }
      } else if (directive) {
        matches = directive.match(backslashNewlineRegex);
        if (matches !== null) {
          opts.line += matches.length;
        }
      } else {
        matches = restOfLine.match(backslashNewlineRegex);
        if (matches !== null) {
          opts.line += matches.length;
        }
      }
      return ++opts.line;
    }
  }
};

analyzeLines = function(file, fileStream, opts) {
  var dirname, formatStream, inComment, lineStream, outStream;
  opts.line = 1;
  opts.file = file;
  opts.isInComment = false;
  dirname = path.dirname(file);
  formatStream = new ConcatBackslashNewlinesStream;
  lineStream = fileStream.pipe(formatStream);
  outStream = new stream.PassThrough();
  if (!opts.ifStack) {
    opts.ifStack = [];
  }
  inComment = false;
  fileStream.on('error', function(err) {
    console.error("Error in reading input file: " + file + ".");
    throw err;
  });
  lineStream.on('data', function(chunk) {
    return processLine(chunk.toString(), outStream, opts, inComment, dirname);
  });
  lineStream.on('end', function() {
    return outStream.emit('end');
  });
  return outStream;
};

module.exports = analyzeLines;

// Generated by CoffeeScript 1.9.2
module.exports = {
  run: function() {

    /*
    accepts -D, -U, -I, -h, -v, and -o arguments
    note: undefs take precedence over defines, and later defines take precedence
    over earlier defines ("earlier" -> earlier in argument list (closer to
    left))
    
    process.argv[0] will be "node", and process.argv[1] will be the compiled
    version of this script, due to the way these are compiled to js before
    execution, and the way this is called from "compp" (an auxiliary script in
    the repo's base directory). this is done because invoking the script through
    the coffeescript interpreter "coffee compp.coffee ..." automatically splits
    process.argv according to the argument parsing done in the coffeescript
    frontend, making the traditional "-DDEFINE" cpp syntax fail. the only
    resolution to this issue (calling this with "/usr/bin/env coffee --")
    doesn't actually work. we will explicitly shift it and change to "coffee"
    here to avoid confusion.
     */
    var analyzeLines, comppGetOpt, defStr, defineStr, defines, fs, hasFoundEqualsSign, i, inStream, j, k, l, len, len1, opts, outStream, path, processedOpts, processedStream, ref, ref1, ref2, ref3, undefStr;
    process.argv.shift();
    process.argv[0] = "coffee";
    fs = require('fs');
    path = require('path');
    comppGetOpt = require(__dirname + "/compp-getopt");
    analyzeLines = require(__dirname + "/analyze-lines");
    opts = comppGetOpt.parseArgsFromArr(process.argv);
    if (opts.help) {
      comppGetOpt.displayHelp();
      process.exit(-1);
    }
    if (opts.version) {
      comppGetOpt.displayVersion();
      process.exit(0);
    }
    if (!((0 < (ref = opts.argv.length) && ref <= 2))) {
      console.error("Please input at least one file for preprocessing.");
      process.exit(-1);
    }
    if (opts.output.length > 1 || (opts.output.length === 1 && opts.argv.length === 2)) {
      console.error("Please input at most one file for output.");
      process.exit(-1);
    }
    if (opts.output.length === 0 && opts.argv.length === 2) {
      opts.output = [opts.argv[1]];
    }
    defines = {};
    ref1 = opts.defines;
    for (j = 0, len = ref1.length; j < len; j++) {
      defStr = ref1[j];
      hasFoundEqualsSign = false;
      for (i = k = 0, ref2 = defStr.length - 1; k <= ref2; i = k += 1) {
        if (defStr.charAt(i) === "=") {
          defines[defStr.substr(0, i)] = {
            text: defStr.substr(i + 1),
            type: "object"
          };
          hasFoundEqualsSign = true;
          break;
        }
      }
      if (!hasFoundEqualsSign) {
        defines[defStr] = {
          text: "",
          type: "object"
        };
      }
    }
    if (opts.defines && opts.undefs) {
      ref3 = opts.undefs;
      for (l = 0, len1 = ref3.length; l < len1; l++) {
        undefStr = ref3[l];
        for (defineStr in defines) {
          if (undefStr === defineStr) {
            delete defines[defineStr];
          }
        }
      }
    }
    if (opts.argv[0] === "-") {
      opts.includes.push(path.resolve(__dirname));
    } else {
      opts.includes.push(path.resolve(path.dirname(opts.argv[0])));
    }
    processedOpts = {
      defines: defines,
      includes: opts.includes
    };
    if (opts.argv[0] === "-") {
      inStream = process.stdin;
    } else {
      inStream = fs.createReadStream(opts.argv[0]);
    }
    processedStream = analyzeLines(opts.argv[0], inStream, processedOpts);
    if (opts.output[0]) {
      outStream = fs.createWriteStream(opts.output[0]);
      outStream.on('error', function(err) {
        console.error("Error in writing to output file: " + opts.output[0] + ".");
        throw err;
      });
    } else {
      outStream = process.stdout;
      outStream.on('error', function(err) {
        console.error("Error in writing to stdout.");
        throw err;
      });
    }
    return processedStream.pipe(outStream);
  }
};

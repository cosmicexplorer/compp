// Generated by CoffeeScript 1.9.2
var PreprocessStream, Transform, dir, fs, gccADir, gccArchDirs, gccVersionDirs, path, sysIncludeDirs,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

Transform = require('stream').Transform;


/*
This sets up the include directories available on the system. It's run once per
call to 'require', and since require is only callable once, it is therefore run
once per program invocation. It scans the system for gcc's include directories
and makes them available to the stream by the array sysIncludeDirs.

TODO: fix this borked broken scheme and find something system-independent.
 */

sysIncludeDirs = ["/usr/local/include", "/usr/include", "/usr/include/linux", "/usr/include/sys"];

gccArchDirs = fs.readdirSync("/usr/lib/gcc").map(function(inode) {
  return path.join("/usr/lib/gcc", inode);
}).filter(function(inode) {
  return fs.statSync(inode).isDirectory();
});

gccVersionDirs = ((function() {
  var j, len, results;
  results = [];
  for (j = 0, len = gccArchDirs.length; j < len; j++) {
    gccADir = gccArchDirs[j];
    results.push(fs.readdirSync(gccADir));
  }
  return results;
})()).map(function(verDirArr) {
  var j, len, results, verDir;
  results = [];
  for (j = 0, len = verDirArr.length; j < len; j++) {
    verDir = verDirArr[j];
    results.push(path.join(gccADir, verDir));
  }
  return results;
}).reduce(function(arr1, arr2) {
  return arr1.concat(arr2);
});

sysIncludeDirs = ((function() {
  var j, len, results;
  results = [];
  for (j = 0, len = gccVersionDirs.length; j < len; j++) {
    dir = gccVersionDirs[j];
    results.push(path.join(dir, "include"));
  }
  return results;
})()).concat(sysIncludeDirs);

module.exports = PreprocessStream = (function(superClass) {
  extend(PreprocessStream, superClass);


  /*
  example inputs:
  
  ps = new PreprocessStream "hello.c", ['/mnt/usr/include'],
    objLikeDefine:
      text: '(2 + 3)'
      type: 'object'
    funcLikeDefine:
      text: 'do { printf("hey"); x; } while(0);'
      type: 'function'
      args: ['x']
   */

  function PreprocessStream(filename, includeDirs, defines1, opts) {
    this.filename = filename;
    this.includeDirs = includeDirs;
    this.defines = defines1;
    if (opts == null) {
      opts = {};
    }
    if (!this instanceof PreprocessStream) {
      return new PreprocessStream;
    } else {
      Transform.call(this, opts);
    }
    this.line = 1;
    this.isInComment = false;

    /*
    stack of #if directives
    each element is laid out as:
    {
      hasBeenTrue: true
      isCurrentlyTrue: no
      ifLine: 342
      ifFile: "test.c"
      ifText: "#ifdef ASDF"
    }
    hasBeenTrue is true so we know whether to process "else" statements
    isCurrentlyTrue tells us whether we're processing the current branch of if
     */
    this.ifStack = [];
    this.curLine = "";
  }

  PreprocessStream.prototype.throwError = function(colNum, errText) {
    var errStr, i, j, ref;
    errStr = this.file + ":" + this.line + ":" + colNum + ": error: " + errText + "\n";
    errStr += this.curLine;
    for (i = j = 1, ref = colNum - 1; j <= ref; i = j += 1) {
      errStr += " ";
    }
    errStr += "^~~\n";
    return this.emit('error', new Error(errStr));
  };

  PreprocessStream.prototype.applyDefines = function(str, macrosExpanded) {
    var argInP, argsArr, argsInParens, defineFunctionRegexStr, defineObjectRegexStr, defineStr, defineVal, definesToSend, i, j, k, l, len, len1, ref, ref1, replaceString, res, tkwArgs, tokensWithArgs;
    str = str.replace(this.constructor.backslashNewlineRegex, "");
    ref = this.defines;
    for (defineStr in ref) {
      defineVal = ref[defineStr];
      defineObjectRegexStr = "\\b" + defineStr + "\\b";
      defineFunctionRegexStr = "\\b" + defineStr + "\\([^\\)]*\\)";
      if ((!macrosExpanded) || (macrosExpanded.indexOf(defineStr) === -1)) {
        if (macrosExpanded) {
          definesToSend = macrosExpanded;
        } else {
          definesToSend = [];
        }

        /*
        this regex construction is safe because valid tokens for #defines
        will only contain [a-zA-z0-9_], as shown above in tokenRegex.
        if there were hyphens, backslashes, or other such weird things, we
        would have to perform the appropriate escaping.
         */
        if (defineVal.type === "object" && str.match(new RegExp(defineObjectRegexStr, "g"))) {
          definesToSend.push(defineStr);
          replaceString = applyDefines(defineVal.text, definesToSend);
          str = str.replace(new RegExp(defineObjectRegexStr, "g"), replaceString);
        } else if (defineVal.type === "function" && str.match(new RegExp(defineFunctionRegexStr, "g"))) {
          definesToSend.push(defineStr);
          tokensWithArgs = str.match(new RegExp(defineFunctionRegexStr, "g"));
          for (j = 0, len = tokensWithArgs.length; j < len; j++) {
            tkwArgs = tokensWithArgs[j];
            argsInParens = tkwArgs.match(parentheticalExprRegex)[0];
          }
          argsArr = [];
          for (k = 0, len1 = argsInParens.length; k < len1; k++) {
            argInP = argsInParens[k];
            res = (argInP.match(argumentRegex)).map(function(s) {
              return s.replace(parenCommaWhitespaceRegex, "");
            });
            if (res.length === 1 && res[0] === "") {
              res = [];
            }
            argsArr.push(res);
          }
          if (tokensWithArgs.length !== argsArr.length) {
            throw new Error("lengths should be the same here!\n" + ("(this is a bug; " + tokensWithArgs.length + " and " + argsArr.length + ")"));
          }
          for (i = l = 0, ref1 = tokensWithArgs.length - 1; l <= ref1; i = l += 1) {
            str = applyFunctionDefine(defineVal, argsArr[i], tokensWithArgs[i], str, defines, definesToSend, opts, line);
          }
        }
      }
    }
    return str.replace(fileTokenRegex, this.filename).replace(lineTokenRegex, this.line);
  };

  PreprocessStream.prototype.insertInclude = function(directive, restOfLine) {
    var err, filePath, found, headerArr, headerFilename, includeDir, j, len, localHeader, ref, ref1, sysHeader;
    sysHeader = (ref = restOfLine.match(this.constructor.systemHeaderRegex)) != null ? ref[0] : void 0;
    localHeader = (ref1 = restOfLine.match(this.constructor.localHeaderRegex)) != null ? ref1[0] : void 0;
    found = false;
    if (sysHeader) {
      headerFilename = sysHeader.replace(this.constructor.stripSideCaratsRegex, "");
      headerArr = sysIncludeDirs;
    } else if (localHeader) {
      headerFilename = localHeader.replace(this.constructor.stripQuotesRegex, "");
      headerArr = this.includeDirs;
    } else {
      throwError(this.constructor.defineErrorCol, "#include without header");
    }
    headerFilename = headerFilename.replace(this.constructor.leadingWhitespaceRegex, "").replace(this.constructor.trailingWhitespaceRegex, "");
    for (j = 0, len = headerArr.length; j < len; j++) {
      includeDir = headerArr[j];
      try {
        filePath = path.join(includeDir, headerFilename);
        fs.statSync(filePath);
        found = true;
      } catch (_error) {
        err = _error;
      }
      if (found) {
        break;
      }
    }
    if (!found) {
      return throwError(this.constructor.defineErrorCol, "Include file " + headerFilename + " not found.");
    }
  };


  /*
  constants and regexes
   */

  PreprocessStream.defineErrorCol = 2;

  PreprocessStream.directiveRegex = /^\s*#\s*[a-z_]+/g;

  PreprocessStream.tokenRegex = /\b[a-zA-Z_][a-zA-Z0-9_]{0,31}\b/g;

  PreprocessStream.numberRegex = /[0-9]+/g;

  PreprocessStream.backslashNewlineRegex = /\\\n/g;

  PreprocessStream.stringInQuotes = /".*"/g;

  PreprocessStream.condRegex = /(if|else)/g;

  PreprocessStream.notWhitespaceRegex = /[^\s]/g;

  PreprocessStream.leadingWhitespaceRegex = /^\s+/g;

  PreprocessStream.trailingWhitespaceRegex = /\s+$/g;

  PreprocessStream.whitespaceRegex = /\s/g;

  PreprocessStream.multipleWhitespaceRegex = /\s+/g;

  PreprocessStream.hashRegex = /#/g;

  PreprocessStream.C99CommentBackslashRegex = /\/\/.*\\\n/g;

  PreprocessStream.C99CommentNoBackslashRegex = /\/\/.*/g;

  PreprocessStream.slashStarBeginRegex = /\/\*/g;

  PreprocessStream.slashStarEndRegex = /\*\//g;

  PreprocessStream.parentheticalExprRegex = /\([^\)]*\)/g;

  PreprocessStream.parenCommaWhitespaceRegex = /[\(\),\s]/g;

  PreprocessStream.argumentRegex = /[^,]+[,\)]/g;

  PreprocessStream.charInQuotesRegex = /'(.)'/g;

  PreprocessStream.fileTokenRegex = /\b__FILE__\b/g;

  PreprocessStream.lineTokenRegex = /\b__LINE__\b/g;

  PreprocessStream.systemHeaderRegex = /^\s*<.+>/g;

  PreprocessStream.localHeaderRegex = /^\s*".+"/g;

  PreprocessStream.stripSideCaratsRegex = /[<>]/g;

  PreprocessStream.stripQuotesRegex = /"/g;

  PreprocessStream.disallowedConditionalChars = /[^0-9\(\)!%\^&\*\-\+\|\/=~<>\\\s]/g;

  return PreprocessStream;

})(Transform);
